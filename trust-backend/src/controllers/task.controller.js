import { z } from 'zod';
import Task from '../models/Task.js';
import ActivityLog from '../models/ActivityLog.js';

const createTaskSchema = z.object({
  leadId: z.string().optional(),
  participantId: z.string().optional(),
  studyId: z.string().optional(),
  siteId: z.string().optional(),
  title: z.string().min(1),
  description: z.string().optional(),
  type: z.enum(['follow_up', 'screening', 'consent', 'visit', 'documentation', 'communication', 'other']).optional(),
  priority: z.enum(['low', 'medium', 'high', 'urgent']).optional(),
  assignedTo: z.string().optional(),
  dueDate: z.string().datetime().optional(),
  reminderAt: z.string().datetime().optional(),
  stage: z.string().optional(),
  autoGenerated: z.boolean().optional(),
  tags: z.array(z.string()).optional(),
  notes: z.string().optional(),
  isRecurring: z.boolean().optional(),
  recurrencePattern: z.string().optional(),
  recurrenceInterval: z.number().optional(),
  recurrenceEndDate: z.string().datetime().optional()
});

const updateTaskSchema = z.object({
  title: z.string().min(1).optional(),
  description: z.string().optional(),
  type: z.enum(['follow_up', 'screening', 'consent', 'visit', 'documentation', 'communication', 'other']).optional(),
  priority: z.enum(['low', 'medium', 'high', 'urgent']).optional(),
  status: z.enum(['pending', 'in_progress', 'completed', 'cancelled']).optional(),
  assignedTo: z.string().optional(),
  dueDate: z.string().datetime().optional(),
  reminderAt: z.string().datetime().optional(),
  tags: z.array(z.string()).optional(),
  notes: z.string().optional(),
  attachments: z.array(z.object({ name: z.string(), url: z.string() })).optional()
});

export async function createTask(req, res, next) {
  try {
    const body = createTaskSchema.parse(req.body);
    
    // Convert date strings to Date objects
    const data = {
      ...body,
      tenantId: req.user.orgId,
      assignedBy: req.user.id,
      dueDate: body.dueDate ? new Date(body.dueDate) : undefined,
      reminderAt: body.reminderAt ? new Date(body.reminderAt) : undefined,
      recurrenceEndDate: body.recurrenceEndDate ? new Date(body.recurrenceEndDate) : undefined
    };
    
    const task = await Task.create(data);
    
    // Log the activity
    await ActivityLog.create({
      tenantId: req.user.orgId,
      actorId: req.user.id,
      entity: 'task',
      entityId: task._id,
      action: 'task.create',
      to: { 
        title: task.title, 
        type: task.type, 
        priority: task.priority,
        assignedTo: task.assignedTo 
      }
    });
    
    res.status(201).json(task);
  } catch (e) {
    next(e);
  }
}

export async function listTasks(req, res, next) {
  try {
    const { 
      page = 1, 
      limit = 20, 
      status, 
      priority, 
      type, 
      assignedTo,
      leadId,
      participantId,
      studyId,
      siteId,
      overdue,
      dueToday
    } = req.query;
    
    const filter = { tenantId: req.user.orgId };
    
    if (status) filter.status = status;
    if (priority) filter.priority = priority;
    if (type) filter.type = type;
    if (assignedTo) filter.assignedTo = assignedTo;
    if (leadId) filter.leadId = leadId;
    if (participantId) filter.participantId = participantId;
    if (studyId) filter.studyId = studyId;
    if (siteId) filter.siteId = siteId;
    
    // Handle overdue and due today filters
    if (overdue === 'true') {
      filter.dueDate = { $lt: new Date() };
      filter.status = { $in: ['pending', 'in_progress'] };
    } else if (dueToday === 'true') {
      const today = new Date();
      const startOfDay = new Date(today.getFullYear(), today.getMonth(), today.getDate());
      const endOfDay = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 1);
      filter.dueDate = { $gte: startOfDay, $lt: endOfDay };
    }
    
    const result = await Task.find(filter)
      .populate('leadId', 'firstName lastName email phone stage')
      .populate('participantId', 'status')
      .populate('studyId', 'title protocol')
      .populate('siteId', 'name city state')
      .populate('assignedTo', 'name email')
      .populate('assignedBy', 'name email')
      .sort({ dueDate: 1, priority: 1, createdAt: -1 })
      .limit(limit * 1)
      .skip((page - 1) * limit);
    
    const total = await Task.countDocuments(filter);
    
    res.json({
      docs: result,
      totalDocs: total,
      limit: parseInt(limit),
      page: parseInt(page),
      totalPages: Math.ceil(total / limit)
    });
  } catch (e) {
    next(e);
  }
}

export async function getTask(req, res, next) {
  try {
    const { id } = req.params;
    const task = await Task.findOne({ _id: id, tenantId: req.user.orgId })
      .populate('leadId', 'firstName lastName email phone stage')
      .populate('participantId', 'status')
      .populate('studyId', 'title protocol')
      .populate('siteId', 'name city state')
      .populate('assignedTo', 'name email')
      .populate('assignedBy', 'name email');
    
    if (!task) {
      return res.status(404).json({ error: 'Task not found' });
    }
    
    res.json(task);
  } catch (e) {
    next(e);
  }
}

export async function updateTask(req, res, next) {
  try {
    const { id } = req.params;
    const body = updateTaskSchema.parse(req.body);
    
    // Convert date strings to Date objects
    const updateData = { ...body };
    if (body.dueDate) updateData.dueDate = new Date(body.dueDate);
    if (body.reminderAt) updateData.reminderAt = new Date(body.reminderAt);
    
    const task = await Task.findOneAndUpdate(
      { _id: id, tenantId: req.user.orgId },
      updateData,
      { new: true }
    );
    
    if (!task) {
      return res.status(404).json({ error: 'Task not found' });
    }
    
    // Log the activity
    await ActivityLog.create({
      tenantId: req.user.orgId,
      actorId: req.user.id,
      entity: 'task',
      entityId: task._id,
      action: 'task.update',
      to: updateData
    });
    
    res.json(task);
  } catch (e) {
    next(e);
  }
}

export async function completeTask(req, res, next) {
  try {
    const { id } = req.params;
    const { notes } = req.body;
    
    const task = await Task.findOneAndUpdate(
      { _id: id, tenantId: req.user.orgId },
      { 
        status: 'completed',
        completedAt: new Date(),
        notes: notes ? `${task?.notes || ''}\nCompleted: ${notes}`.trim() : task?.notes
      },
      { new: true }
    );
    
    if (!task) {
      return res.status(404).json({ error: 'Task not found' });
    }
    
    // Log the activity
    await ActivityLog.create({
      tenantId: req.user.orgId,
      actorId: req.user.id,
      entity: 'task',
      entityId: task._id,
      action: 'task.complete',
      to: { status: 'completed', completedAt: new Date() }
    });
    
    res.json(task);
  } catch (e) {
    next(e);
  }
}

export async function assignTask(req, res, next) {
  try {
    const { id } = req.params;
    const { assignedTo } = req.body;
    
    const task = await Task.findOneAndUpdate(
      { _id: id, tenantId: req.user.orgId },
      { assignedTo },
      { new: true }
    );
    
    if (!task) {
      return res.status(404).json({ error: 'Task not found' });
    }
    
    // Log the activity
    await ActivityLog.create({
      tenantId: req.user.orgId,
      actorId: req.user.id,
      entity: 'task',
      entityId: task._id,
      action: 'task.assign',
      to: { assignedTo }
    });
    
    res.json(task);
  } catch (e) {
    next(e);
  }
}

export async function getTaskStats(req, res, next) {
  try {
    const { studyId, siteId, assignedTo } = req.query;
    const filter = { tenantId: req.user.orgId };
    
    if (studyId) filter.studyId = studyId;
    if (siteId) filter.siteId = siteId;
    if (assignedTo) filter.assignedTo = assignedTo;
    
    const stats = await Task.aggregate([
      { $match: filter },
      {
        $group: {
          _id: {
            status: '$status',
            priority: '$priority',
            type: '$type'
          },
          count: { $sum: 1 }
        }
      }
    ]);
    
    // Get overdue count
    const overdueCount = await Task.countDocuments({
      ...filter,
      dueDate: { $lt: new Date() },
      status: { $in: ['pending', 'in_progress'] }
    });
    
    res.json({ stats, overdueCount });
  } catch (e) {
    next(e);
  }
}

export async function getMyTasks(req, res, next) {
  try {
    const { status, priority, overdue } = req.query;
    const filter = { 
      tenantId: req.user.orgId,
      assignedTo: req.user.id 
    };
    
    if (status) filter.status = status;
    if (priority) filter.priority = priority;
    if (overdue === 'true') {
      filter.dueDate = { $lt: new Date() };
      filter.status = { $in: ['pending', 'in_progress'] };
    }
    
    const tasks = await Task.find(filter)
      .populate('leadId', 'firstName lastName email phone stage')
      .populate('participantId', 'status')
      .populate('studyId', 'title protocol')
      .populate('siteId', 'name city state')
      .sort({ dueDate: 1, priority: 1, createdAt: -1 });
    
    res.json(tasks);
  } catch (e) {
    next(e);
  }
}